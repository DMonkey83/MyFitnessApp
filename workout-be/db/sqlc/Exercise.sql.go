// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: Exercise.sql

package db

import (
	"context"
)

const createExercise = `-- name: CreateExercise :one
INSERT INTO Exercise (exercise_name,workout_id, description, equipment_name, muscle_group_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING exercise_id, workout_id, equipment_name, exercise_name, description, muscle_group_name, created_at
`

type CreateExerciseParams struct {
	ExerciseName    string          `json:"exercise_name"`
	WorkoutID       int64           `json:"workout_id"`
	Description     string          `json:"description"`
	EquipmentName   string          `json:"equipment_name"`
	MuscleGroupName Musclegroupenum `json:"muscle_group_name"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.ExerciseName,
		arg.WorkoutID,
		arg.Description,
		arg.EquipmentName,
		arg.MuscleGroupName,
	)
	var i Exercise
	err := row.Scan(
		&i.ExerciseID,
		&i.WorkoutID,
		&i.EquipmentName,
		&i.ExerciseName,
		&i.Description,
		&i.MuscleGroupName,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExercise = `-- name: DeleteExercise :exec
DELETE FROM Exercise
WHERE exercise_id = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, exerciseID int64) error {
	_, err := q.db.Exec(ctx, deleteExercise, exerciseID)
	return err
}

const getExercise = `-- name: GetExercise :one
SELECT exercise_id, workout_id, equipment_name, exercise_name, description, muscle_group_name, created_at
FROM Exercise
WHERE exercise_id = $1
`

func (q *Queries) GetExercise(ctx context.Context, exerciseID int64) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExercise, exerciseID)
	var i Exercise
	err := row.Scan(
		&i.ExerciseID,
		&i.WorkoutID,
		&i.EquipmentName,
		&i.ExerciseName,
		&i.Description,
		&i.MuscleGroupName,
		&i.CreatedAt,
	)
	return i, err
}

const listAllExercise = `-- name: ListAllExercise :many
SELECT exercise_id, workout_id, equipment_name, exercise_name, description, muscle_group_name, created_at
FROM Exercise
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $1
OFFSET $2
`

type ListAllExerciseParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllExercise(ctx context.Context, arg ListAllExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listAllExercise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseID,
			&i.WorkoutID,
			&i.EquipmentName,
			&i.ExerciseName,
			&i.Description,
			&i.MuscleGroupName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEquipmentExercise = `-- name: ListEquipmentExercise :many
SELECT exercise_id, workout_id, equipment_name, exercise_name, description, muscle_group_name, created_at
FROM Exercise
WHERE equipment_name = $1
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $2
OFFSET $3
`

type ListEquipmentExerciseParams struct {
	EquipmentName string `json:"equipment_name"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) ListEquipmentExercise(ctx context.Context, arg ListEquipmentExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listEquipmentExercise, arg.EquipmentName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseID,
			&i.WorkoutID,
			&i.EquipmentName,
			&i.ExerciseName,
			&i.Description,
			&i.MuscleGroupName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMuscleGroupExercise = `-- name: ListMuscleGroupExercise :many
SELECT exercise_id, workout_id, equipment_name, exercise_name, description, muscle_group_name, created_at
FROM Exercise
WHERE muscle_group_name = $1
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $2
OFFSET $3
`

type ListMuscleGroupExerciseParams struct {
	MuscleGroupName Musclegroupenum `json:"muscle_group_name"`
	Limit           int32           `json:"limit"`
	Offset          int32           `json:"offset"`
}

func (q *Queries) ListMuscleGroupExercise(ctx context.Context, arg ListMuscleGroupExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listMuscleGroupExercise, arg.MuscleGroupName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseID,
			&i.WorkoutID,
			&i.EquipmentName,
			&i.ExerciseName,
			&i.Description,
			&i.MuscleGroupName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkoutExercise = `-- name: ListWorkoutExercise :many
SELECT exercise_id, workout_id, equipment_name, exercise_name, description, muscle_group_name, created_at
FROM Exercise
WHERE workout_id = $1
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $2
OFFSET $3
`

type ListWorkoutExerciseParams struct {
	WorkoutID int64 `json:"workout_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListWorkoutExercise(ctx context.Context, arg ListWorkoutExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listWorkoutExercise, arg.WorkoutID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseID,
			&i.WorkoutID,
			&i.EquipmentName,
			&i.ExerciseName,
			&i.Description,
			&i.MuscleGroupName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExercise = `-- name: UpdateExercise :one
UPDATE Exercise
SET exercise_name = $2, description = $3, equipment_name = $4, muscle_group_name = $5
WHERE exercise_id = $1
RETURNING exercise_id, workout_id, equipment_name, exercise_name, description, muscle_group_name, created_at
`

type UpdateExerciseParams struct {
	ExerciseID      int64           `json:"exercise_id"`
	ExerciseName    string          `json:"exercise_name"`
	Description     string          `json:"description"`
	EquipmentName   string          `json:"equipment_name"`
	MuscleGroupName Musclegroupenum `json:"muscle_group_name"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, updateExercise,
		arg.ExerciseID,
		arg.ExerciseName,
		arg.Description,
		arg.EquipmentName,
		arg.MuscleGroupName,
	)
	var i Exercise
	err := row.Scan(
		&i.ExerciseID,
		&i.WorkoutID,
		&i.EquipmentName,
		&i.ExerciseName,
		&i.Description,
		&i.MuscleGroupName,
		&i.CreatedAt,
	)
	return i, err
}
