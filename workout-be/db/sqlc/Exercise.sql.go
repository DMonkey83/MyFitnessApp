// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: Exercise.sql

package db

import (
	"context"
)

const createExercise = `-- name: CreateExercise :one
INSERT INTO Exercise (exercise_name, description, equipment_required, muscle_group_name)
VALUES ($1, $2, $3, $4)
RETURNING exercise_name, equipment_required, description, muscle_group_name, created_at
`

type CreateExerciseParams struct {
	ExerciseName      string          `json:"exercise_name"`
	Description       string          `json:"description"`
	EquipmentRequired Equipmenttype   `json:"equipment_required"`
	MuscleGroupName   Musclegroupenum `json:"muscle_group_name"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.ExerciseName,
		arg.Description,
		arg.EquipmentRequired,
		arg.MuscleGroupName,
	)
	var i Exercise
	err := row.Scan(
		&i.ExerciseName,
		&i.EquipmentRequired,
		&i.Description,
		&i.MuscleGroupName,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExercise = `-- name: DeleteExercise :exec
DELETE FROM Exercise
WHERE exercise_name = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, exerciseName string) error {
	_, err := q.db.Exec(ctx, deleteExercise, exerciseName)
	return err
}

const getExercise = `-- name: GetExercise :one
SELECT exercise_name, equipment_required, description, muscle_group_name, created_at
FROM Exercise
WHERE exercise_name = $1
`

func (q *Queries) GetExercise(ctx context.Context, exerciseName string) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExercise, exerciseName)
	var i Exercise
	err := row.Scan(
		&i.ExerciseName,
		&i.EquipmentRequired,
		&i.Description,
		&i.MuscleGroupName,
		&i.CreatedAt,
	)
	return i, err
}

const listAllExercise = `-- name: ListAllExercise :many
SELECT exercise_name, equipment_required, description, muscle_group_name, created_at
FROM Exercise
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $1
OFFSET $2
`

type ListAllExerciseParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllExercise(ctx context.Context, arg ListAllExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listAllExercise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseName,
			&i.EquipmentRequired,
			&i.Description,
			&i.MuscleGroupName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEquipmentExercise = `-- name: ListEquipmentExercise :many
SELECT exercise_name, equipment_required, description, muscle_group_name, created_at
FROM Exercise
WHERE equipment_required = $1
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $2
OFFSET $3
`

type ListEquipmentExerciseParams struct {
	EquipmentRequired Equipmenttype `json:"equipment_required"`
	Limit             int32         `json:"limit"`
	Offset            int32         `json:"offset"`
}

func (q *Queries) ListEquipmentExercise(ctx context.Context, arg ListEquipmentExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listEquipmentExercise, arg.EquipmentRequired, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseName,
			&i.EquipmentRequired,
			&i.Description,
			&i.MuscleGroupName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMuscleGroupExercise = `-- name: ListMuscleGroupExercise :many
SELECT exercise_name, equipment_required, description, muscle_group_name, created_at
FROM Exercise
WHERE muscle_group_name = $1
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $2
OFFSET $3
`

type ListMuscleGroupExerciseParams struct {
	MuscleGroupName Musclegroupenum `json:"muscle_group_name"`
	Limit           int32           `json:"limit"`
	Offset          int32           `json:"offset"`
}

func (q *Queries) ListMuscleGroupExercise(ctx context.Context, arg ListMuscleGroupExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listMuscleGroupExercise, arg.MuscleGroupName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseName,
			&i.EquipmentRequired,
			&i.Description,
			&i.MuscleGroupName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExercise = `-- name: UpdateExercise :one
UPDATE Exercise
SET description = $2, equipment_required = $3, muscle_group_name = $4
WHERE exercise_name = $1
RETURNING exercise_name, equipment_required, description, muscle_group_name, created_at
`

type UpdateExerciseParams struct {
	ExerciseName      string          `json:"exercise_name"`
	Description       string          `json:"description"`
	EquipmentRequired Equipmenttype   `json:"equipment_required"`
	MuscleGroupName   Musclegroupenum `json:"muscle_group_name"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, updateExercise,
		arg.ExerciseName,
		arg.Description,
		arg.EquipmentRequired,
		arg.MuscleGroupName,
	)
	var i Exercise
	err := row.Scan(
		&i.ExerciseName,
		&i.EquipmentRequired,
		&i.Description,
		&i.MuscleGroupName,
		&i.CreatedAt,
	)
	return i, err
}
