// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: Exercise.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createExercise = `-- name: CreateExercise :one
INSERT INTO Exercise (exercise_name,workout_id, description, equipment_id)
VALUES ($1, $2, $3, $4)
RETURNING exercise_id, workout_id, exercise_name, description, equipment_id
`

type CreateExerciseParams struct {
	ExerciseName string      `json:"exercise_name"`
	WorkoutID    int64       `json:"workout_id"`
	Description  pgtype.Text `json:"description"`
	EquipmentID  pgtype.Int8 `json:"equipment_id"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.ExerciseName,
		arg.WorkoutID,
		arg.Description,
		arg.EquipmentID,
	)
	var i Exercise
	err := row.Scan(
		&i.ExerciseID,
		&i.WorkoutID,
		&i.ExerciseName,
		&i.Description,
		&i.EquipmentID,
	)
	return i, err
}

const deleteExercise = `-- name: DeleteExercise :exec
DELETE FROM Exercise
WHERE exercise_id = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, exerciseID int64) error {
	_, err := q.db.Exec(ctx, deleteExercise, exerciseID)
	return err
}

const getExercise = `-- name: GetExercise :one
SELECT exercise_id, workout_id, exercise_name, description, equipment_id
FROM Exercise
WHERE exercise_id = $1
`

func (q *Queries) GetExercise(ctx context.Context, exerciseID int64) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExercise, exerciseID)
	var i Exercise
	err := row.Scan(
		&i.ExerciseID,
		&i.WorkoutID,
		&i.ExerciseName,
		&i.Description,
		&i.EquipmentID,
	)
	return i, err
}

const listAllExercise = `-- name: ListAllExercise :many
SELECT exercise_id, workout_id, exercise_name, description, equipment_id
FROM Exercise
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $1
OFFSET $2
`

type ListAllExerciseParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllExercise(ctx context.Context, arg ListAllExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listAllExercise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseID,
			&i.WorkoutID,
			&i.ExerciseName,
			&i.Description,
			&i.EquipmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkoutExercise = `-- name: ListWorkoutExercise :many
SELECT exercise_id, workout_id, exercise_name, description, equipment_id
FROM Exercise
WHERE workout_id = $1
ORDER BY exercise_name -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $2
OFFSET $3
`

type ListWorkoutExerciseParams struct {
	WorkoutID int64 `json:"workout_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListWorkoutExercise(ctx context.Context, arg ListWorkoutExerciseParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listWorkoutExercise, arg.WorkoutID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ExerciseID,
			&i.WorkoutID,
			&i.ExerciseName,
			&i.Description,
			&i.EquipmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExercise = `-- name: UpdateExercise :one
UPDATE Exercise
SET exercise_name = $2, description = $3, equipment_id = $4
WHERE exercise_id = $1
RETURNING exercise_id, workout_id, exercise_name, description, equipment_id
`

type UpdateExerciseParams struct {
	ExerciseID   int64       `json:"exercise_id"`
	ExerciseName string      `json:"exercise_name"`
	Description  pgtype.Text `json:"description"`
	EquipmentID  pgtype.Int8 `json:"equipment_id"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, updateExercise,
		arg.ExerciseID,
		arg.ExerciseName,
		arg.Description,
		arg.EquipmentID,
	)
	var i Exercise
	err := row.Scan(
		&i.ExerciseID,
		&i.WorkoutID,
		&i.ExerciseName,
		&i.Description,
		&i.EquipmentID,
	)
	return i, err
}
