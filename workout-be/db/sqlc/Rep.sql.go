// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: Rep.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRep = `-- name: CreateRep :one
INSERT INTO Rep (set_id, rep_number, completed, notes)
VALUES ($1, $2, $3, $4)
RETURNING rep_id
`

type CreateRepParams struct {
	SetID     int64       `json:"set_id"`
	RepNumber int32       `json:"rep_number"`
	Completed pgtype.Bool `json:"completed"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) CreateRep(ctx context.Context, arg CreateRepParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRep,
		arg.SetID,
		arg.RepNumber,
		arg.Completed,
		arg.Notes,
	)
	var rep_id int64
	err := row.Scan(&rep_id)
	return rep_id, err
}

const deleteRep = `-- name: DeleteRep :exec
DELETE FROM Rep
WHERE rep_id = $1
`

func (q *Queries) DeleteRep(ctx context.Context, repID int64) error {
	_, err := q.db.Exec(ctx, deleteRep, repID)
	return err
}

const getRep = `-- name: GetRep :one
SELECT rep_id, set_id, rep_number, completed, notes
FROM Rep
WHERE rep_id = $1
`

func (q *Queries) GetRep(ctx context.Context, repID int64) (Rep, error) {
	row := q.db.QueryRow(ctx, getRep, repID)
	var i Rep
	err := row.Scan(
		&i.RepID,
		&i.SetID,
		&i.RepNumber,
		&i.Completed,
		&i.Notes,
	)
	return i, err
}

const listReps = `-- name: ListReps :many
SELECT rep_number, completed, notes
FROM Rep
ORDER BY rep_id -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $1
OFFSET $2
`

type ListRepsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListRepsRow struct {
	RepNumber int32       `json:"rep_number"`
	Completed pgtype.Bool `json:"completed"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) ListReps(ctx context.Context, arg ListRepsParams) ([]ListRepsRow, error) {
	rows, err := q.db.Query(ctx, listReps, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRepsRow{}
	for rows.Next() {
		var i ListRepsRow
		if err := rows.Scan(&i.RepNumber, &i.Completed, &i.Notes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRep = `-- name: UpdateRep :one
UPDATE Rep
SET set_id = $2, rep_number = $3, completed = $4, notes = $5
WHERE rep_id = $1
RETURNING rep_id, set_id, rep_number, completed, notes
`

type UpdateRepParams struct {
	RepID     int64       `json:"rep_id"`
	SetID     int64       `json:"set_id"`
	RepNumber int32       `json:"rep_number"`
	Completed pgtype.Bool `json:"completed"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateRep(ctx context.Context, arg UpdateRepParams) (Rep, error) {
	row := q.db.QueryRow(ctx, updateRep,
		arg.RepID,
		arg.SetID,
		arg.RepNumber,
		arg.Completed,
		arg.Notes,
	)
	var i Rep
	err := row.Scan(
		&i.RepID,
		&i.SetID,
		&i.RepNumber,
		&i.Completed,
		&i.Notes,
	)
	return i, err
}
