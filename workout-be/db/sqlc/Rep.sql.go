// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: Rep.sql

package db

import (
	"context"
)

const createRep = `-- name: CreateRep :one
INSERT INTO Rep (set_id, rep_number, completion_status, notes)
VALUES ($1, $2, $3, $4)
RETURNING rep_id, set_id, rep_number, completion_status, notes, created_at
`

type CreateRepParams struct {
	SetID            int64          `json:"set_id"`
	RepNumber        int32          `json:"rep_number"`
	CompletionStatus Completionenum `json:"completion_status"`
	Notes            string         `json:"notes"`
}

func (q *Queries) CreateRep(ctx context.Context, arg CreateRepParams) (Rep, error) {
	row := q.db.QueryRow(ctx, createRep,
		arg.SetID,
		arg.RepNumber,
		arg.CompletionStatus,
		arg.Notes,
	)
	var i Rep
	err := row.Scan(
		&i.RepID,
		&i.SetID,
		&i.RepNumber,
		&i.CompletionStatus,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRep = `-- name: DeleteRep :exec
DELETE FROM Rep
WHERE rep_id = $1
`

func (q *Queries) DeleteRep(ctx context.Context, repID int64) error {
	_, err := q.db.Exec(ctx, deleteRep, repID)
	return err
}

const getRep = `-- name: GetRep :one
SELECT rep_id, set_id, rep_number, completion_status, notes, created_at
FROM Rep
WHERE rep_id = $1
`

func (q *Queries) GetRep(ctx context.Context, repID int64) (Rep, error) {
	row := q.db.QueryRow(ctx, getRep, repID)
	var i Rep
	err := row.Scan(
		&i.RepID,
		&i.SetID,
		&i.RepNumber,
		&i.CompletionStatus,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const listReps = `-- name: ListReps :many
SELECT rep_id, set_id, rep_number, completion_status, notes, created_at
FROM Rep
WHERE set_id = $1
ORDER BY rep_id -- You can change the ORDER BY clause to order by a different column if needed
LIMIT $2
OFFSET $3
`

type ListRepsParams struct {
	SetID  int64 `json:"set_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListReps(ctx context.Context, arg ListRepsParams) ([]Rep, error) {
	rows, err := q.db.Query(ctx, listReps, arg.SetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rep{}
	for rows.Next() {
		var i Rep
		if err := rows.Scan(
			&i.RepID,
			&i.SetID,
			&i.RepNumber,
			&i.CompletionStatus,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRep = `-- name: UpdateRep :one
UPDATE Rep
SET rep_number = $2, completion_status = $3, notes = $4
WHERE rep_id = $1
RETURNING rep_id, set_id, rep_number, completion_status, notes, created_at
`

type UpdateRepParams struct {
	RepID            int64          `json:"rep_id"`
	RepNumber        int32          `json:"rep_number"`
	CompletionStatus Completionenum `json:"completion_status"`
	Notes            string         `json:"notes"`
}

func (q *Queries) UpdateRep(ctx context.Context, arg UpdateRepParams) (Rep, error) {
	row := q.db.QueryRow(ctx, updateRep,
		arg.RepID,
		arg.RepNumber,
		arg.CompletionStatus,
		arg.Notes,
	)
	var i Rep
	err := row.Scan(
		&i.RepID,
		&i.SetID,
		&i.RepNumber,
		&i.CompletionStatus,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
